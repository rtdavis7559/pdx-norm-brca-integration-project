---
title: "10X Norm/BRCA and SmartSeq2 TNBC PDX Model Integration"
author: "Ryan and Paige"
date: "4/5/2020"
output: html_document
---

## Load R packages
##Seurat, dpylr, reshape2, ggplot2, patchwork, cowplot needed
```{r load.packages}
#install.packages("Seurat")
library(Seurat)
library(dplyr)
library(reshape2)
#library(SeuratData)
```

## Load in seurat objects

```{r load.objects,eval=FALSE,echo=FALSE}
#HCI001
load("/Users/paigehalas/ph-future-phd/pdx-norm-brca-integration-project/seurat-objects/hci001.expected.counts.trimmed.seurat3.object.Rda")
#HCI002
load("/Users/paigehalas/ph-future-phd/pdx-norm-brca-integration-project/seurat-objects/hci002.expected.counts.trimmed.seurat3.object.Rda")
#HCI010
load("/Users/paigehalas/ph-future-phd/pdx-norm-brca-integration-project/seurat-objects/hci010.expected.counts.trimmed.seurat3.object.Rda")
#Norm/BRCA
load("/Users/paigehalas/ph-future-phd/pdx-norm-brca-integration-project/seurat-objects/norm.brca.integrated.epithelial.Rda")
```

## Set Default Assays to "RNA" for all datasets

```{r set.default.assay, eval=FALSE}
## Data Integration - Standard Workflow
DefaultAssay(p01.counts) <- "RNA"
DefaultAssay(p02.counts) <- "RNA"
DefaultAssay(p10.counts) <- "RNA"
DefaultAssay(norm.brca.integrated.epithelial) <- "RNA"
```


## Subset Norm/BRCA Dataset to Epithelial Cells 

```{r subset.normbrca.dataset.compartment, eval=FALSE}
#SplitObject command will generate subsets of a Seurat object in list form based on the given metadata column. For this, we subset on the "Compartment" column, to generate two new objects, the epithelial compartment and the stromal compartment
norm.brca.subset.objects<-SplitObject(norm.brca.integrated.epithelial,"Compartment")

#We now seperate out each component of the list into seperate Seurat objects. The "$" command specifies which part of the full list we want to access.
norm.brca.epithelial.object<-norm.brca.subset.objects$EPITHELIAL
norm.brca.stromal.object<-norm.brca.subset.objects$STROMAL
```
```{r check.columns.and.the.epithelial.subset, echo=FALSE, eval=FALSE}
colnames(norm.brca.epithelial.object@meta.data)
head(norm.brca.epithelial.object$Compartment)
```
## Subset Norm/BRCA Dataset by Individual

```{r subset.normbrca.dataset.individual, eval=FALSE}
#SplitObject command will generate subsets of a Seurat object in list form based on the given metadata column. For this, we subset on the "individual" column, to generate 6 new objects, for each patient. 
norm.brca.epithelial.individual.objects<-SplitObject(norm.brca.epithelial.object,"individual")

#We now seperate out each component of the list into seperate Seurat objects. The "$" command specifies which part of the full list we want to access.
norm.brca.epithelial.individual.1.objects<-norm.brca.epithelial.individual.objects$ind1
norm.brca.epithelial.individual.2.objects<-norm.brca.epithelial.individual.objects$ind2
norm.brca.epithelial.individual.3.objects<-norm.brca.epithelial.individual.objects$ind3
norm.brca.epithelial.individual.4.objects<-norm.brca.epithelial.individual.objects$ind4
norm.brca.epithelial.individual.9.objects<-norm.brca.epithelial.individual.objects$ind9
norm.brca.epithelial.individual.10.objects<-norm.brca.epithelial.individual.objects$ind10
```
```{r check.columns.and.the.individual.subset,eval=FALSE,echo=FALSE}
colnames(norm.brca.epithelial.individual.1.objects@meta.data)
head(norm.brca.epithelial.individual.1.objects@meta.data)
```

## Generate a list of Seurat objects (PDX models and Norm/BRCA Individuals) to perform the standard workflow integration on

```{r standard.workflow.generate.object.list, eval=FALSE}
#To construct a reference, we will identify ‘anchors’ between the individual datasets. First, we combine each Seurat object into a list, with each dataset as an element.
#The list() function groups elements together in the form of list("X1"=Y1,"X2",Y2,...), where Xn is the name you want the list element to be called and Yn is the component you want added to the list. For this analysis, we want to keep track of which Seurat object belongs to which model/patient.
#first part 
standard.workflow.object.list <- 
#list("hci001"=p01.cc.updated,"hci002"=p02.updated,"hci010"=p10.updated)
list("hci001"=p01.counts,"hci002"=p02.counts,"hci010"=p10.counts,"n_patient1"=norm.brca.epithelial.individual.1.objects, "b_patient2"=norm.brca.epithelial.individual.2.objects, "b_patient3"=norm.brca.epithelial.individual.3.objects, "b_patient4" = norm.brca.epithelial.individual.4.objects, "n_patient9" = norm.brca.epithelial.individual.9.objects, "n_patient10"=norm.brca.epithelial.individual.10.objects )
```

## Preprocessing before finding anchors by normalizing the data and identifying variable features 

```{r standard.workflow.normalize.objects, eval=FALSE}
#Prior to finding anchors, we perform standard preprocessing (log-normalization), and identify variable features individually for each. Note that Seurat v3 implements an improved method for variable feature selection based on a variance stabilizing transformation ("vst")
for (i in 1:length(standard.workflow.object.list)) {
    standard.workflow.object.list[[i]] <- NormalizeData(standard.workflow.object.list[[i]], verbose = TRUE)
    standard.workflow.object.list[[i]] <- FindVariableFeatures(standard.workflow.object.list[[i]], selection.method = "vst", 
        nfeatures = 2000, verbose = TRUE)
}
```

## Find the integration anchors for the PDX and Norm/BRCA datasets


```{r standard.workflow.find.integration.anchors, eval=FALSE}
#Next we find anchors, which are pairwise correspondants between individual cells which originate from the same biological state. These anchors are then used to transfer infromation from one dataset to another
reference.list <- standard.workflow.object.list
integration.anchors <- FindIntegrationAnchors(object.list = reference.list, dims = 1:30)
```

## Integration of Data using the defined anchors 

```{r standard.workflow.integrate.data,eval=FALSE}
#After 
#if hitting vector limit issue, open terminal, set cd to home directory, use "open .Renviron" and set the R_MAX_VSIZE=20Gb and save the file, you need to restart R for these changes to be saved 
integrated.data <- IntegrateData(anchorset = integration.anchors, dims = 1:30)
#save(integrated.data, file = "/Users/paigehalas/Desktop/integrated.data.Rda")
```

## Load Integrated Data

``` {r load.integrated.data}
load("/Users/paigehalas/Desktop/integrated.data.Rda")
```

## Load Libraries for Visualization of Data

```{r visualize.integration.matrix}
#load necessary packages for visualization 
library(ggplot2)
library(cowplot)
library(patchwork)

# switch to integrated assay. The variable features of this assay are automatically
# set during IntegrateData
#DefaultAssay(integrated.data) <- "integrated"
```

## Scale integrated data, run PCA and plot via UMAP 
```{r standard.workflow.sacle.integrated.data,eval = FALSE}
scale.integrated.data <- ScaleData(integrated.data, verbose = TRUE)
PCA.integrated.data<- RunPCA(scale.integrated.data, npcs = 30, verbose = TRUE)
UMAP.integrated.data <- RunUMAP(PCA.integrated.data, reduction = "pca", dims = 1:30)
#saveRDS(UMAP.integrated.data, file = "/Users/paigehalas/Desktop/UMAP.integrated.data.rds")
```

## Integration Visualization 

```{r standard.workflow.integration.visualization, fig.height=4, fig.width=8}
UMAP.integrated.data <- readRDS("/Users/paigehalas/Desktop/UMAP.integrated.data.rds")
DimPlot(UMAP.integrated.data, reduction = "umap", label = TRUE)
```

## Feature plot for nFeature_RNA to compare PDX cells and Norm/BRCA cells  

```{r look.at.feature.plot.for.nFeature_RNA, fig.height=4, fig.width=8}
FeaturePlot(UMAP.integrated.data, features = "nFeature_RNA", label=TRUE)
```

## Recalculate the percent mito using the Seurat tutorial 

```{r look.at.percent.mito}
#integrated.data <- load("Users/paigehalas/Desktop/integrated.data.rda")
DefaultAssay(UMAP.integrated.data) <- "RNA"
UMAP.integrated.data[["percent.mt"]] <- PercentageFeatureSet(UMAP.integrated.data, pattern = "^MT-")
```

## Plot UMAP with the new percent mito 

```{r plot.new.UMAP.percent.mito, fig.height=4, fig.width=8}
FeaturePlot(UMAP.integrated.data, features = "percent.mt")
```

## Rescale the data to account for differences in n_Feature and percent mito 

```{r rescale.PCA.MAP.data.and.look.at.feature.plots, eval = FALSE}
DefaultAssay(integrated.data) <- "integrated"
r.scale.integrated.data <- ScaleData(integrated.data,vars.to.regress=c("nFeature_RNA", "percent.mt"))
r.PCA.integrated.data<- RunPCA(r.scale.integrated.data, npcs = 30, verbose = TRUE)
r.UMAP.integrated.data <- RunUMAP(r.PCA.integrated.data, reduction = "pca", dims = 1:30)
saveRDS(r.UMAP.integrated.data, file = "/Users/paigehalas/Desktop/r.UMAP.integrated.data.rds")
```

## Look at the UMAP and feature plots for n_Feature and percent mito 

```{r look.at.UMAP.with.new.mito.and.feature.plots, fig.height=4, fig.width=8}
r.UMAP.integrated.data <- readRDS("/Users/paigehalas/Desktop/r.UMAP.integrated.data.rds")
DimPlot(r.UMAP.integrated.data, reduction = "umap", label = TRUE)
FeaturePlot(r.UMAP.integrated.data, features = "nFeature_RNA")
FeaturePlot(r.UMAP.integrated.data, features = "percent.mito")
```


## Define cluster markers (this is not finished yet)

```{r look.at.cluser.markers, eval=FALSE}
#markers <- FindAllMarkers(UMAP.integrated.data, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
#UMAP.integrated.data %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
```

## Adding columns for dataset types

```{r adding.metadata.column, eval=FALSE}
#Generate new list for the dataset type
#Combined_Classification <- list ()
#Adding the five different classifications to the list 
#Combined_Classification[grep("NORMAL",UMAP.integrated.data$Status)] <- "Normal"
#Combined_Classification[grep("BRCA",UMAP.integrated.data$Status)] <- "BRCA"
#Combined_Classification[grep("HCI001",UMAP.integrated.data$patient.id)] <- "HCI001"
#Combined_Classification[grep("HCI002",UMAP.integrated.data$patient.id)] <- "HCI002"
#Combined_Classification[grep("HCI010",UMAP.integrated.data$patient.id)] <- "HCI010"
#Add new metadata column 
#UMAP.integrated.data[["Combined_Classification"]] <- as.character(Combined_Classification)
```

## Adding cell types to the dataset

```{r combined.cell.type, eval = FALSE}
#Generate new list for the cell type
#Combined_Cell_Type <- list()
#Get the lung and lymph cells from the PDX models that are metastatic
#Combined_Cell_Type[grep("Lung", UMAP.integrated.data$tissue)] <- "Metastatic"
#Combined_Cell_Type[grep("Lymph", UMAP.integrated.data$tissue)] <- "Metastatic"
#Get the tumor cells from the PDX models that are tumor cells 
#Combined_Cell_Type[grep("Tumor", UMAP.integrated.data$tissue)] <- "Tumor"
#Get the cell types from Kevins Norm/BRCA dataset 
#Combined_Cell_Type[grep("Basal", UMAP.integrated.data$Cell.Type)] <- "Basal"
#Combined_Cell_Type[grep("Luminal_1", UMAP.integrated.data$Cell.Type)] <- "Luminal_1"
#Combined_Cell_Type[grep("Luminal_2", UMAP.integrated.data$Cell.Type)] <- "Luminal_2"
#Combined_Cell_Type[grep("Unclassified", UMAP.integrated.data$Cell.Type)] <- "Unclassified"
#Add new column 
#UMAP.integrated.data[["Combined_Cell_Type"]] <- as.character(Combined_Cell_Type)
```