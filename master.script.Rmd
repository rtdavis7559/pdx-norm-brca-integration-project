---
title: "10X Norm/BRCA and SmartSeq2 TNBC PDX Model Integration"
author: "Ryan and Paige"
date: "4/5/2020"
output: html_document
---

## Load R packages

```{r load.packages}
library(Seurat)
library(dplyr)
library(reshape2)
library(ggplot2)
library(patchwork)
```

## Load in seurat objects

```{r load.objects}
setwd("/Users/ryan/pdx-norm-brca-integration-project")
#HCI001
load("seurat-objects/hci001.seurat3.object.Rda")
#HCI002
load("seurat-objects/hci002.seurat3.object.Rda")
#HCI010
load("seurat-objects/hci010.seurat3.object.Rda")
#Norm/BRCA
load("seurat-objects/norm.brca.integrated.epithelial.Rda")
```

## Subset Norm/BRCA Dataset to Norm/BRCA

```{r subset.normbrca.dataset}
#SplitObject command will generate subsets of a Seurat object in list form based on the given metadata column. For this, we subset on the "Compartment" column, to generate two new objects, the epithelial compartment and the stromal compartment
norm.brca.subset.objects<-SplitObject(Norm.BRCA.integrated,"Compartment")

#We now seperate out each component of the list into seperate Seurat objects. The "$" command specifies which part of the full list we want to access.
norm.brca.epithelial.object<-norm.brca.subset.objects$EPITHELIAL
norm.brca.stromal.object<-norm.brca.subset.objects$STROMAL
```

## Data Integration - scTransform

```{r sctransform.generate.object.list}
#To construct a reference, we will identify ‘anchors’ between the individual datasets. First, we combine each Seurat object into a list, with each dataset as an element.
#The list() function groups elements together in the form of list("X1"=Y1,"X2",Y2,...), where Xn is the name you want the list element to be called and Yn is the component you want added to the list. For this analysis, we want to keep track of which Seurat object belongs to which model/patient.
sctransform.object.list <- list("hci001"=p01.cc.updated,"hci002"=p02.updated,"hci010"=p10.updated,"norm"=norm.brca.integrated.epithelial)
```
```{r sctransform.normalize.objects}
#Conceptually, this workflow is very similar to what we have previously introduced, where we ‘correct’ (or harmonize) log-normalized expression values across datasets. Here, instead, we will harmonize the Pearson residuals that are output from SCTransform.
#First, setup the Seurat object list, and run SCTransform on each object separately
for (i in 1:length(sctransform.object.list)) {
    sctransform.object.list[[i]] <- SCTransform(sctransform.object.list[[i]], verbose = FALSE)
}
```
```{r sctransform.feature.selection}
#Next, select features for downstream integration, and run PrepSCTIntegration, which ensures that all necessary Pearson residuals have been calculated.
#Running on 3000 selected features (may test others later)
norm.brca.pdx.features.3000 <- SelectIntegrationFeatures(object.list = sctransform.object.list, 
                                                         nfeatures = 3000)
#need to increase globals size limit otherwise the next line will error (will need to be adjusted for size of future datasets)
options(future.globals.maxSize = (6000*1024^2))

norm.brca.pdx.features.list.3000 <- PrepSCTIntegration(object.list = sctransform.object.list, 
                                                  anchor.features = norm.brca.pdx.features.3000, 
                                                  verbose = FALSE)
```
```{r sctransform.integrate}
#Next, identify anchors and integrate the datasets. Commands are identical to the standard workflow, but make sure to set normalization.method = 'SCT':

norm.brca.pdx.anchors <- FindIntegrationAnchors(object.list = norm.brca.pdx.features.list.3000, normalization.method = "SCT", 
    anchor.features = norm.brca.pdx.features.3000, verbose = FALSE)
norm.brca.pdx.integrated <- IntegrateData(anchorset = norm.brca.pdx.anchors, normalization.method = "SCT", 
    verbose = FALSE)

save(norm.brca.pdx.integrated, file="E:/Scripts/Seurat/Seurat3_Objects/norm.brca.pdx.integrated.sctransform.3000features.SeuratObject.Rda")
```

##Dimentionality Reduction and Clustering

```{r }
#Now proceed with downstream analysis (i.e. visualization, clustering) on the integrated dataset. Commands are identical to the standard workflow, but do not run the ScaleData function after integration. You can see that after integration, cells group by their biological cell type (which has been pre-annotated), instead of by their underlying technology.

norm.brca.pdx.integrated <- RunPCA(norm.brca.pdx.integrated, verbose = FALSE)
norm.brca.pdx.integrated <- RunUMAP(norm.brca.pdx.integrated, dims = 1:30)
```

##Adding MetaData

```{r add.meta.data}
#Generate new list for the dataset type
combined_status <- list ()
#Adding the five different classifications to the list 
combined_status[grep("NORMAL",norm.brca.pdx.integrated$Status)] <- "Normal"
combined_status[grep("BRCA",norm.brca.pdx.integrated$Status)] <- "BRCA"
combined_status[grep("HCI001",norm.brca.pdx.integrated$patient.id)] <- "HCI001"
combined_status[grep("HCI002",norm.brca.pdx.integrated$patient.id)] <- "HCI002"
combined_status[grep("HCI010",norm.brca.pdx.integrated$patient.id)] <- "HCI010"
#Add new metadata column 
norm.brca.pdx.integrated[["combined_status"]] <- as.character(combined_status)

#Generate new list for the cell type
Combined_Cell_Type <- list()
#Get the lung and lymph cells from the PDX models that are metastatic
Combined_Cell_Type[grep("Lung", norm.brca.pdx.integrated$tissue)] <- "Metastatic"
Combined_Cell_Type[grep("Lymph", norm.brca.pdx.integrated$tissue)] <- "Metastatic"
#Get the tumor cells from the PDX models that are tumor cells 
Combined_Cell_Type[grep("Tumor", norm.brca.pdx.integrated$tissue)] <- "Tumor"
#Get the cell types from Kevins Norm/BRCA dataset 
Combined_Cell_Type[grep("Basal", norm.brca.pdx.integrated$Cell.Type)] <- "Basal"
Combined_Cell_Type[grep("Luminal_1", norm.brca.pdx.integrated$Cell.Type)] <- "Luminal_1"
Combined_Cell_Type[grep("Luminal_2", norm.brca.pdx.integrated$Cell.Type)] <- "Luminal_2"
Combined_Cell_Type[grep("Unclassified", norm.brca.pdx.integrated$Cell.Type)] <- "Unclassified"
#Add new column 
norm.brca.pdx.integrated[["Combined_Cell_Type"]] <- as.character(Combined_Cell_Type)
```

##Visualizing Data

```{r sctransform.visualize}
DimPlot(norm.brca.pdx.integrated, group.by = "combined_status",pt.size = 0.5)
DimPlot(norm.brca.pdx.integrated, group.by = "combined_status",split.by = "Combined_Cell_Type", ncol = 2,pt.size = 0.5)
```